("(exit)" "(synthesize #:forall '() #:guarantee (assert #t))" "(synthesize #:forall '() #:guarantee (assert #f))" "(sat? (synthesize #:forall '() #:guarantee #f))" "(synthesize #:forall '() #:guarantee #f)" "(synthesize #:forall '() #:guarantee #t)" "(synthesize 1 #:forall (list) #:guarantee #t)" "(synthesize x-sym #:forall '() #:guarantee #t)" "(synthesize 1 #:guarantee #t)" "(synthesize 1 #:forall '())" "(synthesize 1 #:forall '() #:guarantee #f)" "(synthesize 1 #:forall '() #:guarantee #t)" "solve" "(exit)" "((bitvector 32) (integer->bitvector 3 (bitvector 32)))" "((bitvector 32) (integer->bitvector 3 32))" "((bitvector 32) (integer->bitvector 3))" "((bitvector 32) #f)" "((bitvector 32) #t)" "((bitvector 32) 101)" "((bitvector 32) 0)" "(bitvector 32 0)" "(bitvector 32)" "(expand 'bitvector)" "bitvector" "int32?" "(assert #f)" "(assert #t)" "(sat? res)" "(unsat? res)" "(sat? res)" "res" "(exit)" "(plot-function
         sin 0 0.1 \"sin\")" "(adaptive-plot identity 0 1)" "(adaptive-plot sin 0 1)" "(+ 1 'a)" "node" "(struct node (val))" "(#%require racket)" "(struct node (val))" "(require racket)" "(expand '(when #t 3))" "(when #t 3)" "(struct node (val))" "(exit)" "(struct node (x))" "(require racket)" "(struct node (x))" "exit" "1" "(exit)" "errortrace-key" "atom?" "(diff '(+ (* 2 x) (* 3 x)) 'x)" "(diff (+ (* 2 x) (* 3 x)) 'x)" "(diff (+ (* 2 x) (* 3 x)))" "(simplify (D '(+ x z (* y z x) (* y x)) 'x))" "(simplify (D '(+ x z (* y z) (* y x)) 'x))" "(simplify (D '(+ x (* y x)) 'x))" "zero?" "(simplify (D '(+ x (* y x)) 'x))" "(D '(+ x (* y x)) 'x)" "(D 'x 'x)" "(D 'x 'y)" "(D 'x 'x)" "(exit)" "(main)" "(exit)" "exit" "(exit)" ",bt" "(exit)" "(main)" "(exit)" "((f))" "(f f)" "(f)" "f" "(define (f) f)" "(f 3)")